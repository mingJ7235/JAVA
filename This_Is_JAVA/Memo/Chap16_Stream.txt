1-1 스트림 Intro
○스트림?
- 스트림은 반복자!
	- 컬렉션 (배열 포함)의 요소를 하나씩 참조해서 람다식으로 처리할 수 있는 반복자다.
	=> 람다식은 자바 1.8 버전부터 사용가능 즉, 스트림도 1.8이상부터!

	자바7 이전에는 Iterator를 사용했음
	자바8 부터는 스트림이 간편함  올? 
	List <String> list = Array.asList ("홍길동", "신용권", "감자바");
	String<String> stream = list.stream();
	String.forEach(name -> syso(name));

	※forEach : 반복해서 가지고와라! 라는 의미임
	※Stream을 쓰면 간결함


○특징1 : 람다식 요소처리! 
- 람디식으로 요소 처리 코드를 제공한다
	- 람다식은 반복적으로 처리하는 것에 강하다.
	- 스트림이 제공하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개타입을 가진다.
	=> 함수적 인터페이스? -> 메소드가 하나뿐인 인터페이스! 
	=> 즉, 람다식으로 매개값이 제공될수있다는 것. 메소드가 하나여야함
	- 매개값으로 람다식 또는 메소드 참조를 대입할 수있다. 

	※forEach 역시 함수적 인터페이스가 매개변수임

EX>
package sec01.stream_introduction;
public class Student {
	private String name;
	private int score;

	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

	public int getScore() {
		return score;
	}
	public void setScore(int score) {
		this.score = score;
	}
}
====================================
package sec01.stream_introduction;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class LambdaExpressionsEX {
	public static void main(String[] args) {
		List <Student> list = Arrays.asList(
				new Student ("홍길동", 90),
				new Student ("신용권", 92)
				);
		
		Stream <Student> stream = list.stream();
		stream.forEach(s -> {	//람다식 표현
			String name = s.getName();
			int score = s.getScore();
			System.out.println(name + " - " + score);
		});		
	}
}
======================================

○ 특징 2 : 내부 반복자를 사용하므로 병렬처리가 쉽다.

- 외부 반복자 (external iterator)
	- iterator가 대표적이다.
	- 개발자가 코드로 직접 컬렉션 요소를 반복해서 요청하고 가져오는 코드 패턴임
	- 즉, iterator로 가져올 때 hasNext()와 next() 를 사용해서 코드로 가져오도록 하는것
	- 컬렉션 내부가 아니라, 외부에서 가져오도록 하는 것임.
	- 개발자 코드, 즉, while문을 사용하여 컬렉션의 요소를 가져오기위해 iterator 메소드를 사용한 것임.

- 내부 반복자 (internal iterator)
	- stream 을 활용한 람다식 표현이 대표적
	- 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야할 코드만
	제공하는 코드 패턴 ! 
	- 개발자 코드는 stream에 주어지는 람다식 표현임. 
	- 컬렉션 내부에서 람다식으로 요소적으로 반복함

- 내부 반복자의 이점
	- 개발자는 요소 처리 코드에만 집중하면됨 개편함
		-> iterator는 일일히 확인해야 한다. 
		-> 다음 요소를 가져와라 라는 것을 지정해줘야함. 
		-> 하지만 stream은 요소를 어떻게 처리할것인가만 쓰면댐
	- 멀티 코어 cpu를 최대한 활용하기 위해 요소들을 분배시켜
	병렬 처리 작업을 할 수 있다.
		-> 컬렉션의 요소가 많을 경우 별도의 stream처리하여 병렬적으로 처리 가능
		-> 외부 반복자를 사용하면 병렬 처리를 하려면 스레드를 만들어서 처리해야한다.
		-> 그러므로 외부반복자를 사용하면 코드가 상당히 복잡하다.

- 병렬 처리란?
	- 한가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로
	처리한 후 , 서브 작업들의 결과들을 최종 결합하는 방법
		-> 
	- 내부적으로 자바는 ForkJoinPool 프레임워크를 이용해서 병렬 처리를 한다.
	- 병렬처리는 stream을 사용하면 매우 쉽다. 뭔말인지모르겠지만 stream 짱짱맨임;
	- parallelStream() 메소드 사용 ! -> 병렬로 가능함.
		=> 병렬 처리할 때 이 메소드만 간편하게 사용하면 땡임. 올ㅋ
		=> 즉, 직접 스레드를 만들어서 처리하지 않음! 
		=> 이 메소드만 사용하면, 자바가 알아서 만들어서 처리해줌 올!!


○ 특징 3 : 스트림은 중간처리와 최종 처리를 할 수 있다.
- 중간 처리 : 요소들의 매핑, 필터링, 정렬
- 최종 처리 : 반복, 카운트, 평균, 총합


EX> 남학생 여학생이 섞인 컬렉션에서
	- 중간처리 (필터) : 남학생, 여학생 구분 후 남학생만 필터링
	- 중간처리 (매핑) : 학생의 개별 점수를 뽑아냄
	- 최종처리 (평균) : 개별 점수의 평균값을 산출
	=> 이것을 스트림으로 모두 만드는 것임.

List에 저장된 Student 객체를 중간처리에서 score 필드값으로 매핑하고, 최종처리에서 score평균값 산출
================================
package sec01.stream_introduction;

import java.util.Arrays;
import java.util.List;

public class MapAndReduceEx {
	public static void main(String[] args) {
		
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 10),
				new Student("신용권", 20),
				new Student("유미선", 30)
		);
		
		//중간처리 : 매핑!! mapTo타입 () 으로 해서 그 해당 타입으로 새로 stream의 요소로 바꾸는 것 
		//최종처리 : 평균!! average() !!!
//		studentList.stream().mapToInt(s->s.getScore()) 이방식도있고
		double avg = studentList.stream()	 //오리지날 스트림
				.mapToInt(Student :: getScore) //중간 처리하여, 매핑하는것. 스튜던트에서 스코어를 얻어내는것
				.average()	//최종처리. 중간에서 얻은 점수 스트림을 활용하여 평균값을 구하는 매소드. 근데 이게 리턴하는 것이 OptionalDouble이라서
				.getAsDouble();	// getAsDouble() 메소드를 활용하여 average() 값을 리턴하도록함.
		
		System.out.println("평균 점수 : "  + avg);
		
	}
}

=================================

