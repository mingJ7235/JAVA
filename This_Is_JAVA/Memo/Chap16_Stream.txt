1-1 스트림 Intro
○스트림?
- 스트림은 반복자!
	- 컬렉션 (배열 포함)의 요소를 하나씩 참조해서 람다식으로 처리할 수 있는 반복자다.
	=> 람다식은 자바 1.8 버전부터 사용가능 즉, 스트림도 1.8이상부터!

	자바7 이전에는 Iterator를 사용했음
	자바8 부터는 스트림이 간편함  올? 
	List <String> list = Array.asList ("홍길동", "신용권", "감자바");
	String<String> stream = list.stream();
	String.forEach(name -> syso(name));

	※forEach : 반복해서 가지고와라! 라는 의미임
	※Stream을 쓰면 간결함


○특징1 : 람다식 요소처리! 
- 람디식으로 요소 처리 코드를 제공한다
	- 람다식은 반복적으로 처리하는 것에 강하다.
	- 스트림이 제공하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개타입을 가진다.
	=> 함수적 인터페이스? -> 메소드가 하나뿐인 인터페이스! 
	=> 즉, 람다식으로 매개값이 제공될수있다는 것. 메소드가 하나여야함
	- 매개값으로 람다식 또는 메소드 참조를 대입할 수있다. 

	※forEach 역시 함수적 인터페이스가 매개변수임

EX>
package sec01.stream_introduction;
public class Student {
	private String name;
	private int score;

	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

	public int getScore() {
		return score;
	}
	public void setScore(int score) {
		this.score = score;
	}
}
====================================
package sec01.stream_introduction;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class LambdaExpressionsEX {
	public static void main(String[] args) {
		List <Student> list = Arrays.asList(
				new Student ("홍길동", 90),
				new Student ("신용권", 92)
				);
		
		Stream <Student> stream = list.stream();
		stream.forEach(s -> {	//람다식 표현
			String name = s.getName();
			int score = s.getScore();
			System.out.println(name + " - " + score);
		});		
	}
}
======================================

○ 특징 2 : 내부 반복자를 사용하므로 병렬처리가 쉽다.

- 외부 반복자 (external iterator)
	- iterator가 대표적이다.
	- 개발자가 코드로 직접 컬렉션 요소를 반복해서 요청하고 가져오는 코드 패턴임
	- 즉, iterator로 가져올 때 hasNext()와 next() 를 사용해서 코드로 가져오도록 하는것
	- 컬렉션 내부가 아니라, 외부에서 가져오도록 하는 것임.
	- 개발자 코드, 즉, while문을 사용하여 컬렉션의 요소를 가져오기위해 iterator 메소드를 사용한 것임.

- 내부 반복자 (internal iterator)
	- stream 을 활용한 람다식 표현이 대표적
	- 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야할 코드만
	제공하는 코드 패턴 ! 
	- 개발자 코드는 stream에 주어지는 람다식 표현임. 
	- 컬렉션 내부에서 람다식으로 요소적으로 반복함

- 내부 반복자의 이점
	- 개발자는 요소 처리 코드에만 집중하면됨 개편함
		-> iterator는 일일히 확인해야 한다. 
		-> 다음 요소를 가져와라 라는 것을 지정해줘야함. 
		-> 하지만 stream은 요소를 어떻게 처리할것인가만 쓰면댐
	- 멀티 코어 cpu를 최대한 활용하기 위해 요소들을 분배시켜
	병렬 처리 작업을 할 수 있다.
		-> 컬렉션의 요소가 많을 경우 별도의 stream처리하여 병렬적으로 처리 가능
		-> 외부 반복자를 사용하면 병렬 처리를 하려면 스레드를 만들어서 처리해야한다.
		-> 그러므로 외부반복자를 사용하면 코드가 상당히 복잡하다.

- 병렬 처리란?
	- 한가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로
	처리한 후 , 서브 작업들의 결과들을 최종 결합하는 방법
		-> 
	- 내부적으로 자바는 ForkJoinPool 프레임워크를 이용해서 병렬 처리를 한다.
	- 병렬처리는 stream을 사용하면 매우 쉽다. 뭔말인지모르겠지만 stream 짱짱맨임;
	- parallelStream() 메소드 사용 ! -> 병렬로 가능함.
		=> 병렬 처리할 때 이 메소드만 간편하게 사용하면 땡임. 올ㅋ
		=> 즉, 직접 스레드를 만들어서 처리하지 않음! 
		=> 이 메소드만 사용하면, 자바가 알아서 만들어서 처리해줌 올!!


○ 특징 3 : 스트림은 중간처리와 최종 처리를 할 수 있다.
- 중간 처리 : 요소들의 매핑, 필터링, 정렬
- 최종 처리 : 반복, 카운트, 평균, 총합


EX> 남학생 여학생이 섞인 컬렉션에서
	- 중간처리 (필터) : 남학생, 여학생 구분 후 남학생만 필터링
	- 중간처리 (매핑) : 학생의 개별 점수를 뽑아냄
	- 최종처리 (평균) : 개별 점수의 평균값을 산출
	=> 이것을 스트림으로 모두 만드는 것임.

List에 저장된 Student 객체를 중간처리에서 score 필드값으로 매핑하고, 최종처리에서 score평균값 산출
================================
package sec01.stream_introduction;

import java.util.Arrays;
import java.util.List;

public class MapAndReduceEx {
	public static void main(String[] args) {
		
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 10),
				new Student("신용권", 20),
				new Student("유미선", 30)
		);
		
		//중간처리 : 매핑!! mapTo타입 () 으로 해서 그 해당 타입으로 새로 stream의 요소로 바꾸는 것 
		//최종처리 : 평균!! average() !!!
//		studentList.stream().mapToInt(s->s.getScore()) 이방식도있고
		double avg = studentList.stream()	 //오리지날 스트림
				.mapToInt(Student :: getScore) //중간 처리하여, 매핑하는것. 스튜던트에서 스코어를 얻어내는것
				.average()	//최종처리. 중간에서 얻은 점수 스트림을 활용하여 평균값을 구하는 매소드. 근데 이게 리턴하는 것이 OptionalDouble이라서
				.getAsDouble();	// getAsDouble() 메소드를 활용하여 average() 값을 리턴하도록함.
		
		System.out.println("평균 점수 : "  + avg);
		
	}
}

=================================

1-2 스트림의 종류
○ 스트림이 포함된 패키지
	- JAVA 1.8 부터 java.util.stream 패키지에서 인터페이스 타입으로 제공
	
BaseStream : 모든 스트림에서 사용할 수 있는 공통 메소드들이 정의되어 있을 뿐
		코드에서 직접적으로 사용되지는 않는다.!!
		이것을 상속한 하위 stream들을 사용함

Stream : 객체 요소를 처리하는 스트림
IntStream, LongStream, DoubleStream : 기본타입인 int, long, double요소를 처리하는 스트림


○ 스트림 구현 객체를 얻는 방법
1> 컬렉션으로부터 스트림 얻기
1-1에서 했던 것 반복. 
forEach(s -< syso(s.getName())); -> 람다식 ! 

2> 배열로부터 스트림 얻기
요소에 따라서 리턴값이 다르므로 Stream을 골라서 써야한다
객체일경우 : Stream <T>
숫자인경우 : IntStream, LongStream, DoubleStream

=====
package sec02.stream_kind;

import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class FromArrayEx {
	public static void main(String[] args) {
		//배열에서 스트림얻어오는 법
		String [] strArray = {"홍길동", "신용권", "김미나"};
		Stream<String> strStream = Arrays.stream(strArray); //Arrays.stream(배열)
		strStream.forEach(a -> System.out.print(a + ", ")); //a는 요소를 대입함. 
		
		System.out.println();
		
		int [] intArray = {1,2,3,4,5};
		IntStream intStream = Arrays.stream(intArray);
		intStream.forEach(i -> System.out.print(i + ", "));
		
	}
}
=====

3> 숫자 범위로부터 스트림 얻기
IntStream에는 range와 rangeClosed라는 범위를 구하는 메소드가 있다. 
-> 범위를 지정하여 요소를 가져오는 메소드임. 

※ range와 rangeClosed 메소드 차이
rangeClosed(1, 100) -> 1~100
range(1,100) ->1 ~99

========
package sec02.stream_kind;

import java.util.stream.IntStream;

public class FromIntRangeEx {
	
	public static int sum;
	
	public static void main(String[] args) {
		
		IntStream stream = IntStream.rangeClosed(1, 100);
		stream.forEach(n -> sum += n);
		System.out.println("총합 : " + sum);
	}
}
======

4> 파일로부터 스트림 얻기.
Path, BufferedReader 객체는 IO에서 더 다룰것 지금은 그냥 아 이런게 있다라고 볼것

Files.lines()는 각각의 라인을 가지고 오는 것임. 
즉, 문자로 이뤄진 파일의 한 줄을 가지고 오는 것임. 

BufferedReader 의 lines() 메소드
=> file 이름을 매개값으로 가져감
==================
package sec02.stream_kind;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class FromFileContentEx {
	public static void main(String[] args) throws IOException{
		//문자파일안에 있는 라인별로 처리하는 스트림
		Path path = Paths.get("src/sec02/stream_kind/linedata.txt");
		Stream <String> stream; //문자열이므로 String
		
		//1. Files.lines() 이용
		stream = Files.lines(path, Charset.defaultCharset());
		stream.forEach(System.out :: println); //메소드 참조법
//		stream.forEach(s -> System.out.println(s)); //람다식 이용법
		stream.close();
		System.out.println();
		
		//2. BufferedReader의 lines() 이용
		File file = path.toFile();
		FileReader fileReader = new FileReader(file);
		//문자를 읽을때 사용하는 스트림 : FileReader
		BufferedReader br = new BufferedReader(fileReader); //속도향상을 위해 bufferedreader사용
		stream = br.lines();
		stream.forEach(System.out :: println);
		stream.close();
	}
}
===================

5> 디렉토리로부터 스트림 얻기
이것 역시 path를 사용하여 얻는다. 
path객체 자체가 stream의 객체가 되는 것이다. 
즉, 서브 디렉토리 또는 파일 목록!! 이 스크림을 통해서 읽는 것이다. 

package sec02.stream_kind;

import java.io.IOError;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class FromDirectoryEx {
	public static void main(String[] args) throws IOException{
		Path path = Paths.get("C:/Users/User/Desktop/GitHub/JAVA/This_Is_JAVA");
		Stream<Path> stream = Files.list(path);
		stream.forEach(p -> System.out.println(p.getFileName())); //폴더, 파일명 모두 다 출력이됨. 그 목록을 출력하는 것임
		
	}
}

1-3 스트림 파이프라인
○ 중간 처리와 최종 처리
스트림은 중간 처리와 최종처리로 구분되는데, 최종처리에 리덕션이라는 행위를 함

- 리덕션 (Reduction) 
	- 대량의 데이터를 가공해서 축소하는 것을 말한다.
		=> 합계, 평균값, 카운팅, 최대값, 최소값등을 집계하는것

	- 요소가 리덕션의 결과물로 바로 집계할 수 없을경우 중간 처리가 필요하다.
		=> 중간처리란?  : 필터링, 매핑, 정렬, 그룹핑 등

	- 중간 처리한 요소를 최종 처리해서 리덕션 결과물을 산출한다!


- 스트림은 중간처리와 최종처리를 파이프라인 (pipelines)로 해결한다!
	- 파이프라인 : 스트림을 파이프처럼 이어 놓은 것을 말한다. 
		=> 중간처리 메소드는 중간 처리된 스트림을 리턴하고
		=> 이스트림에서 다시 중간 처리 메소드를 호출하여 파이프라인을 형성하게 된다.
	Ex> 오리지날 스트림 -> 필터링 처리 중간스트림 -> 매핑처리 중간스트림 
		-> 집계처리 결과물 -> 결과
	- 최종 스트림의 집계 기능이 시작되기 전까지 중간 처리는 지연(lazy) 된다.
		-> 최종 스트림이 시작하면 비로소 컬렉션에서 요소가 하나씩 중간 스트림에서
		처리되고 최종 스트림까지 오게된다.
		-> 즉, 최종처리 스트림이 시작해야 중간 처리 스트림이 동작하기 시작한다는 것.
		-> 미리 중간 스트림이 돌아가서 준비되어있다가 최종처리를 하는것이 아님!
		-> 최종 처리를 시작하는 순간! 오리지날 스트림에서부터 시작하여
		중간처리 스트림이 시작된다.
		-> 이것을 중간처리 지연(lazy)라고 한다. 


==========
package sec03.stream_pipelines;

public class Member {
	public static int MALE = 0;
	public static int FEMALE = 1;
	
	private String name;
	private int sex;
	private int age;

	public Member(String name, int sex, int age) {
		this.name = name;
		this.sex = sex;
		this.age = age;
	}

	public int getSex() {
		return sex;
	}

	public int getAge() {
		return age;
	}
}
===============
package sec03.stream_pipelines;

import java.util.Arrays;
import java.util.List;

public class StreamPipelinesEx {
	public static void main(String[] args) {
		List <Member> list = Arrays.asList(  
			new Member("홍길동", Member.MALE, 30),
			new Member("김나리", Member.FEMALE, 20),	
			new Member("신용권", Member.MALE, 45),	
			new Member("박수미", Member.FEMALE, 27)	
		);
		
		double maleAgeAvg= list.stream()							//메인 스트림
				.filter(m -> m.getSex() == Member.MALE)		//filter 중간 스트림
				.mapToInt(Member :: getAge)							//mapping 중간 스트림
				.average()															//average() 최종 스트림
				.getAsDouble();													//Optionaldouble 타입을 double로 변환
		
		
		double femaleAgeAve = list.stream()
				.filter(m -> m.getSex()==Member.FEMALE)
				.mapToInt(Member :: getAge)
				.average().getAsDouble();
		
		
		System.out.println("남자 평균 나이 :"  + maleAgeAvg);
		System.out.println("여자 평균 나이 :"  + femaleAgeAve);
	}
}
=========================
○ 중간처리 메소드와 최종 처림 메소드
- 리턴 타입을 보면 중간 처리 메소드인지 최종 처리 메소드인지 구분할 수 있다.
	= 중간 처리메소드 : 리턴 타입이 스트림!!!
	= 최종 처리 메소드: 리턴 타입이 기본타입(int, double등) 이거나 Optional클래스 이다!
	=> 구분하는거 매우 중요함!!!
- 중간 처리 메소드를 구현한다고해서 스트림이 작동하지 않는다.
	=> 최종스트림의 집계 기능이 시작되어야 중간처리도 시작된다!!!
		=> lazy!!!! 중간이는 최종이가 움직여야 움직임. 게으르다. 라고 생각하잣


- 중간처리
	=> 필터링, 매핑, 정렬, 루핑 의 종류가 있다.
	필터링 : 요소들을 추려냄 
		distinct() : 중복을 걸러냄
		filter() : 필터링
	매핑 : 모든 스트림에서 제공하는것도, 특정 스트림에서 제공하는것도 있음. 소속된 인터페이스가 다 다름
		매핑 메소드 개많음
	정렬 : 정렬!
		sorted()
	루핑 : 루핑!
		peek()

- 최종 처리 메소드
	=> 매칭, 집계, 루핑, 수집 의 종류가있다.
	매칭 : 주어진 조건에 맞냐 안맞냐 조사 -> return 이 boolean이다.
	집계 : 카운트, 최대최소값, 평균, 합, reduce는 사용자 정의한 값등등
	루핑 : 요소를 반복적으로 가져와서 처리하는 것
		-> forEach()가 대표적
	수집 : 요소들을 별도의 컬렉션으로 수집할때 사용
		-> 리턴 값이 객체다. 

1-4 필터링
○ 필터링 - distinct (), filter()
- 중간 처리 기능으로 요소를 걸러내는 역할을 한다. 

○distinct ()
	- 오리지날 스트림이 Stream : equals() 메소드가 true가 나오면 동일한 객체로 판단하고 중복을 제거한다.
	=> 즉, equals()로 동일객체 판단
	- 오리지날 스트림이 IntStream, LongStream, DoubleStream : 동일 값일 경우 중복을 제거

○ filter (Predicate)
	- 매개값으로 주어진 Predicate가 true를 리턴하는 요소만 필터링한다. 	




