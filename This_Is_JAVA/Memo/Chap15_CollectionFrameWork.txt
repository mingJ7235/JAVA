1-1 CollectionFrameWork 개요
○컬렉션
	- 요소(객체)를 수집하여 저장하는 것
○배열의 문제점
	- JAVA에서  컬렉션을 제공해주는 이유임!!
	=> 저장할 수 있는 객체수가 배열을 생성할 때 결정된다. (배열의 길이가 정해짐)
		-> 불특정 다수의 객체를 저장하기에는 문제가 있다.
	=> 객체를 삭제 했을 때 해당 인덱스가 비게 된다. 
		-> 낱알 빠진 옥수수같이... 비유 찰지는구만
		-> 객체를 저장하려면 어디가 비어있는 지 확인해야한다.
		-> 그 검사하는 코드를 먼저 사용해야하므로 비효율적임.
	=> 컬렉션은 이 두가지 문제를 해결!

○컬렉션 프레임워크
	- 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 제공되는 컬렉션 라이브러리
	- 프레임워크 : 인터페이스와 클래스의 모음이라고 생각하면 됨!!
	- java.util 패키지에 포함된다. 
	- 인터페이스를 통해서 정형화된 방법으로 다양한 클렉션 클래스를 이용! 
		=> 컬렉션을 사용하는 방법이 통일되어있어서 매우 쉽게 사용가능하다!

※ 컬렉션 프레임워크의 주요 인터페이스
	-List
	=> 배열과 유사하게 인덱스로 관리
	=> 인덱스에 객체를 저장
		- 구현 클래스 : ArrayList, Vector, LinkedList
	=특징
		- 순서를 유지하고 저장 (인덱스)
		- 중복 저장이 가능하다. 
	
	-Set
	=> 집합과 유사하다.
	=> 구술 주머니와 비슷. 객체를 주머니에 저장 한다고 생각하기
		-구현 클래스 : HashSet, TreeSet
	=특징
		- 순서를 유지하지 않고 저장 ! 주머니에 저장~!!
		- 중복 저장 불가! (주머니에 똑같은거 못들어감)	
			=> 동일한 객체를 넣으면 오류남

	-Map
	=> 키와 값의 쌍으로 객체를 관리
	=> List와 유사하지만, List는 인덱스로 저장하는 것에 반해
	Key로 저장을 한다. 각 Key마다 객체가 저장이되고, 쌍으로 관리된다. 
		- 구현 클래스 : HashMap, HashTable, TreeMap, Properties
	=특징
		- 키와 값의 쌍으로 저장이 된다. 
		- 키는 중복 저장이 안된다. (List의 인덱스가 중복이 말이안되는것처럼)
		- 키가 다르다면 값은 중복으로 저장 가능하다.


1-2 List 컬렉션
List인터페이스를 구현한 컬렉션
○특징
	- 인덱스로 관리
	- 중복해서 객체 저장 가능
	- 실질적으로는 해당 인덱스에 객체의 주소값이 저장되는것임!
○구현 클래스
	-ArrayList
	-Vector
	-LinkedList
○주요 메소드
- 객체추가
	=boolean add(E element)
	-> 주어진 객체를 List의 맨 끝에 추가
	-> return 값이 boolean. 성공적으로 추가되면 true가 리턴됨

	=void add(int index, E element)
	-> 주어진 인덱스에 객체를 추가
	-> 객체를 수정하는 것이아니라, 새로운 공간이 생기고 기존 인덱스는 뒤로 밀림.
	-> 중간에 삽입을 하는것이다.!
	
	=set (int index, E element)
	-> 주어진 인덱스에 저장된 객체를 주어진 객체로 바꿈! 이것은 수정!
 
-객체검색
	=boolean contains(Object o)
	-> 주어진 객체가 저장되어 있는지 여부를 리턴함

	=E get (int index)
	-> 가장 많이 사용함
	-> 주어진 인덱스에 저장된 객체를 리턴한다. 
	-> 즉, 인덱스에 있는 객체를 불러올 때 사용!
	
	=boolean isEmpty()
	-> 컬렉션 자체가 비어있는지 아닌지를 살핀다. 
	-> 비어있으면 true, 비어있지 않으면 false

	=int size()
	-> 저장되어있는 전체 객체수!! 를 리턴한다. (length라고 생각하면댐)
	-> 객체가 중복되어도, 인덱스에 저장된것을 센다.

- 객체 삭제
	= void clear()
	-> 컬렉션 안에 저장된 모든 객체를 삭제함

	= E remove (int index)
	-> 해당 인덱스에 저장된 객체를 삭제하고, 삭제된 객체가 리턴된다.
	-> 인덱스를 알고있으면 이걸 사용

	= boolean remove(Object O)
	-> 주어진 객체를 삭제한다. 
	-> 객체를 알고있으면 이걸 사용
	-> 중복된 객체라면 그 해당 객체를 담은 인덱스가 모두 삭제된다. 
	

○ArrayList 클래스
List <E> list = new ArrayList <E> ();

- 저장용량 (capacity)
	-초기값 : 10
	-초기 용량 지정가능하다. 생성자의 매개값에 넣으면댐
	-저장용량을 초과한 객체들이 들어오면 자동적으로 늘어난다. 이것이 배열과 차이!

- 객체 제거
	- 객체가 제거되면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다
	

- 고정된 객체들로 구성된 List 생성
=>객체들이 고정되어있다면 add를 사용하면 도리어 불편함
List<T> list = Arrays.asList(T....a);
	=> Arrays.asList()를 사용하는것이 간편

List<String> list1 = Arrays.asList("홍길동", "신용권", "김자바");
for(String name : list1) {
	syso (name);
}

○Vector 클래스
List <E> list = new Vector <E> ();
- 특징
	= Vector는 스레드 동기화 (synchronization) 되어있기 때문에
	복수의 스레드가 동시에 vector에 접근해서 객체를 추가, 삭제하더라도
	스레드에 안전(thread safe) 하다. 
	=> ArrayList와 사용이 똑같지만, 멀티스레드환경에서 사용한다.
	=> ArrayList는 싱글스레드에서 사용된다. 

※ArrayList
	public boolean add {...}

Vector
	public synchronized boolean add {...}

즉, Vector는 메소드가 동기화되어있으므로 멀티스레스환경에서 안전하다!
즉, 하나의 스레드가 실행하고있으면 다른 스레드들이 사용하지 못한다. 
두 스레드가 동시에 어떤 객체를 Vector에 저장하려고할때,
어떤 스레드부터 저장할것인가? 에대한 고민을 해결시켜줌. 

그러나 싱글스레드에서는 ArrayList가 좀더 빠르게 작업을 처리하므로,
싱글스레드에서는 ArrayList를 사용한다. 

○LinkedList 클래스
List <E> list = new LinkedList <E> ();
-특징
	= 인접 참조를 링크해서 '체인' 처럼 관리
	= 말그대로 linked !! -> 앞에 누가있고 뒤에 누가있는지를 저장함
	= 특정 인덱스에서 객체를 제거하거나 추가하게 되면 바로 앞뒤 링크만 변경된다
	= 빈번한 객체 삭제와 삽입이 일어나는 곳에서는 ArrayList보다 성능이 좋다. 
	= 즉, 연결을 끊고 새로 연결을 만드는 것임
	= 나머지 요소에 대한 수정이 없고 
	= ArrayList나 Vector는 모두 전체 객체들의 인덱스가 수정되는데,
	LinkedList는 그 링크들, 즉 체인만 끊고 수정만 하면된다. 
	=> 객체 삭제, 삽입에 있어서 수정되어야할부분이 최소화 된다. 즉, 빠르다!

1-3 Set 컬렉션
○ Set 컬렉션 특징 및 주요 메소드
- 특징
	= 수학의 집합에 비유될 수 있다. (중복 x, 순서상관없다.
	= 저장 순서가 유지 되지 않는다.
	= 객체를 중복해서 저장할 수 없다.
	= 하나의 null만 저장할 수있다. -> null도 저장이 가능한데 이것도 하나만!
	= 주머니 속에 모두 다른 구슬을 넣은 구조라고 생각하면된다!

- 구현 클래스 : HashSet, LinkedHashSet, TreeSet

- 주요 메소드
1) 객체 추가 
	boolean add ( E e )
 
2) 객체 검색 (인덱스로 검색할 수 없다! 인덱스를 가지고 검색 불가)
	boolean contains (Obejct o)

	isEmpty()

	Iterator <E> iterator ()
	: 반복자. 저장된 객체를 한번씩 가져오는 반복자 리턴한다. 
	
	int size()

3) 객체 삭제 (인덱스를 삭제하는 것 없음! 인덱스 자체가 없으니까)
	void clear()
		
	boolean remove(Object o)
	
○Iterator :  Set 컬렉션에서의 검색
- Set 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없다.
- 대신, 전체 객체를 대상으로 한번씩 반복해서 가져오는 반복자(Iterator)를 제공한다.

Iterator < > iterator = set.iterator();

boolean hasNext () : 가져올 객체가 있으면 true, 없으면 false로 리턴
E next () : 컬렉션에서 하나의 객체를 가져온다. 리턴!!
void remove() : Set 컬렉션에서 객체를 제거한다. 


○HashSet

Set <E> set = new HashSet<E>();

-특징
	= 동일 객체 및 동등 객체는 중복 저장하지 않는다.
	= 동등 객체 판단 방법
	-> hashCode() 리턴값을 비교, equals() 리턴값을 비교. 이 두가지가 모두 같으면
	동등 객체다. 

1-3 Map 컬렉션
○특징
	- 키와 값으로 구성된 Map.Entry 객체를 저장하는 구조
	- 키와 값은 모두 객체다!!!
	- 키는 중복 될수 없지만! 값은 중복 저장 가능!
	
	- 구현 클래스 : HashMap, Hashtable, LinkedHashMap, Properties, TreeMap

○주요 메소드
1) 객체 추가
	V put (K key, V value) : 키와 값을 저장. 

2) 객체 검색
	boolean containsKey (Object key) : 주어진 키가 있는지 여부
	boolean containsValue (object key ) : 주어진 값이 있는지 여부
	Set <Map.Entry <K,V>> entryset () : 키와 값의 쌍으로 구성된 모든 Map.Entry 객체를
					set에 담아서 리턴!
		=> Set으로 담는 이유는 Iterator를 통해 검색하기 위해서임 반복자 사용
	V get(Object Key) : 주어진 키의 값을 리턴 ( 키를 주면 값을 뱉음!)
	boolean isEmpty () : 컬렉션이 비어있는지 여부
	Set <K> keySet() : 모든 키를 Set 객체에 담아서 리턴
	int size () 저장된 키의 총 수를 리턴
	Collection <V> values() 저장된 모든 값 Collection 에 담아서 리턴

3) 객체 삭제
	void clear()  : 모든 Map.Entry(키와 값)을 삭제
	V remove (Object key) : 주어진 키와 일치하는 Map.Entry 삭제, 삭제되면 값을 리턴

○HashMap
Map <K, V> map = new HashMap <K, V> ();

-특징
	= 키 객체는 hashCode()와 equals()를 재정의해서 동등 객체가 될 조건을 정해야 한다.
		-> key 중복을 피하기 위해서
	= 키 타입은 주로 String을 많이 사용한다
	->String은 문자열이 같은경우 동등 객체가 될수 있도록 하기 위해서다. 
	즉, String은 hashcode()와 eqauls() 메소드가 재정이 되어있기 때문에!











