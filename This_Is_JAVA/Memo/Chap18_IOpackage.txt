1-1 IO패키지 소개
○java.io패키지
	->자바의 기본적인 데이터 입출력 API제공

1-2 입력 스트림과 출력스트림
○입력스트림과 출력스트림 개념
프로그램을 기준으로 데이터가 들어오게되면 입력스트림을 이용
데이터가 나가게되면 출력스트림을 이용한다.

스트림 : 데이터의 흐름

입력스트림 
- 데이터의 출발지 : 키보드, 파일, 프로그램등
	-> 여기서 데이터들이 흘러서들어옴
출력스트림
- 데이터의 도착지 : 모니터, 파일, 프로그램등
	-> 여기로 데이터들이 흘러나감

데이터가 들어오는것 : 입력스트림
데이터가 나가는것 : 출력스트림
프로그램의 기준에 따라 같은 스트림이어도 상대적으로 입력스트림과 출력스트림의 입장이 다름

프로그램 A 도착지 < -- 입력스트림 --  <-- 출력스트림 -- 출발지 프로그램 B

○ 바이트기반 스트림과 문자 기반 스트림
- 바이트 기반 스트림
	-그림, 멀티미디어, 문자등 모든 종류의 데이터를 받고 보낼 수 있다.

- 최상위 클래스 
	-입력 : InputStream
		하위클래스 : XXXInputStream
		ex) FileInputStream
	-출력 : OutputStream
		하위클래스 : XXXOutputStream
		ex) FileOutputStream

- 문자 기반 스트림
	- 문자만 받고 보낼 수 있도록 특화되어 있다.

-최상위 클래스
	-입력 : Reader
		하위클래스 : XXXReader
		ex) FileReader
	-출력 : Writer
		하위클래스 : XXXWriter
		ex) FileWriter


○InputStream

- 바이트 기반 입력 스트림의 최상위 클래스로 추상클래스이다. 
	-> 즉, 객체화를 할 수 없다는 것임
	-> 하위클래스로 객체화해야함 

- 대표적 하위 클래스 : FileInputStream, BufferedInputStream, DataInputStream... 

- 주요 메소드
1) read () : 입력 스트림으로부터 1바이트를 읽고 읽은 바이트를 리턴한다.
	리턴타입 : int 
	=> int는 4바이트인데, read()가 읽은 1바이트가 4바이트중 가장 끝에 저장된다. 


2) read(byte[] b) : 입력 스트림으로부터 읽은 바이트들을 매개값으로 주어진 바이트 배열 b에
		저장하고 실제로 읽은 바이트 수를 리턴한다. 
		즉, 데이터 저장은 배열에하고, 리턴은 바이트 수를 하는것
		read()와 다르다!!
		리턴타입 : int
3) read (byte[] b, int off, int len) :  입력 스트림으로부터 len 개의 바이트 만큼 읽고
		매개값으로 주어진 바이트 배열 b[off] 부터 len 개까지 저장한다.
		즉, off는 배열의 인덱스 번호다!
		그리고 실제로 읽은 바이트 수인 len 개를 리턴한다.
		만약 len개를 모두 읽지 못하면 실제로 읽은 바이트 수를 리턴한다.
		리턴 타입 : int


4) close () :  사용한 시스템 자원을 반납하고 입력 스트림을 닫는다.
	inputstream을 사용하면 닫아줘야함 !


○read()메소드
※read() 더이상 읽을게 없으면 -1을 리턴한다.


○read(byte[] b) 메소드
-> 배열에 바이트의 데이터를 저장,
-> 실재 읽은 바이트의 수를 리턴
※ 배열에 공간이 남아있다면 직전에 읽었던 데이터가 그자리에 그대로 남아있다.
※ 더이상 읽을게 없으면 -1을 리턴한다.

○ read (byte[] b, int off, int len) 메소드
-> 배열에 바이트의 데이터를 저장
-> 실재 읽은 바이트의 수를 리턴
-> 배열의 인덱스번호 (off) 부터 len 만큼의 정보를 저장함


○ close() 메소드
	-InputStream을 더이상 사용하지 않을 경우 호출해준다.
	-InputStream에서 사용했던 시스템 자원을 풀어준다.
	※반드시 close를 해줘야한다!



○OutputStream
- 바이트 기반 출력 스트림의 최상위 클래스로 추상클래스다.
	-> 즉, InputStream과 마찬가지로 객체 생성 X
	-> 대신에 하위클래스를 가지고 객체를 생성한다.

-대표적 하위 클래스 : FileOutputStream, PrintStream, BufferedOutputStream, DataOutputStream

- 주요 메소드

1) write (int b) : 출력 스트림으로 1바이트를 보낸다.
	마찬가지로, int가 4바이트이지만, 끝 1바이트만 출력한다.

2) write (byte[] b) : 출력 스트림에 매개값으로 주어진 바이트 배열 b의 바이트를 보낸다.

3) write (byte[] b, int off, int len) : 뭔느낌인지 알지?

4) flush () : write를 하게 되면 데이터가 바로 출력되는것이 아니라
메모리 버퍼에 쌓였다가 버퍼가 꽉차면 데이터를 출력함,
데이터가 꽉차지 않았을 경우 강제적으로 데이터를 출력하도록 해주는 메소드임
즉, 버퍼에 잔류하는 모든 바이트를 출력한다.
그러므로 write를 하고 flush를 해야 데이터가 출력이된다!

5) close() : 더이상 outputStream을 사용하지 않으면 출력스트림을 닫아준다!

○ write (int b) 메소드


○ write (byte [] b) 메소드
-> write (int b) 와 다르게 배열을 통째로 한번에 출력한다.

○ write (byte [] b , int off, int len) 메소드


○flush () 와 close()
어떠한 출력 스트림을 사용하고나서도  write를 했다면 flush를 해야한다.
반드시 !!! 그래야 데이터가 출력이 된다. 
더이상 출력스트림을 사용하지 않으면 close를 해야한다. 


○Reader
- 문자 기반 입력 스트림의 최상위 클래스로 추상 클래스다.
- 문자만 읽을 수 있고 byte는 읽을 수 없다. 

- 대표적 클래스 : FileReader, BufferedReader, InputStreamReader

- 주요 메소드
1) read() : 입력 스트림으로 부터 한개의 문자를 읽고 리턴한다.
		-> 한 문자는 2바이트이므로 리턴하는 int 4바이트 중에 끝 2바이트에 저장
2) read (char[] cbuf) : 읽은 문자들을 char배열에 저장하고, 읽은 문자 수는 리턴한다.

3) read (char[] cbuf, int off , int len ) : 읽은 문자들을 char에 저장, 배열의 시작인덱스 off부터
		len만큼 저장한다. 그리고 실제 읽은 문자수를 리턴
4) close () : 닫기!



○read() 메소드
	-> 한번에 한 문자를 읽는다! (2바이트) 
※ 더이상 읽을 문자가 없으면 -1을 리턴함! 

○ read(char[] cbuf) 메소드

○ read(char[] cbuf, int off, int len) 메소드


○ Writer
	-문자기반 출력 스트림의 최상위 클래스로 추상 클래스

- 메소드
1) write (int c) : 매개값으로 주어진 한 문자를 보낸다.

2) write (char [] cbuf) : 배열의 모든 문자를 출력

3) write (char [] cbuf, int off, int len)

4) write (String str) 매개값으로 주어진 문자열을 전부

5) write (String str, int off, int len)

6) flush ()

7) close ()


1-3 콘솔 입출력
○콘솔 Console 
	- 시스템을 사용하기 위해 키보드로 입력을 받고 화면으로 출력하는 소프트웨어
System.out : 출력 스트림
System.in : 입력스트림

○System.in 필드
	-InputStream 타입의 입력 스트림 이므로 InputStream 변수에 대입할 수있다.
		- InputStream is = System.in;
	-읽은 byte는 키보드의 아스키코드 이다. 
	- 아스키 코드로부터 문자로읽기위해서 char로 변환 시킨다.


○ 키보드로 부터 입력된 한글 읽기
-> 한글은 2바이트로 되어있다. 
-> 바이트 배열에 담아야한다. 

○ Scanner 쓰면댐;

1-4 파일 입출력

○File 클래스
- 파일 시스템의 파일을 표현하는 클래스
	- 파일 크기, 파일 속성, 파일 이름등의 정보를 제공한다.
	- 파일 생성 및 삭제 기능 제공
	- 디렉토리를 생성하고 디렉토리에 존재하는 파일리스트를 얻어내는 기능 제공
	(File이라고해서 파일만 관여하지 않음. 디렉토리도 관리함)

- 파일 객체 생성
	File file = new File ("파일이나 디렉토리의 경로가 매개값!");

- 파일 또는 디렉토리 존재 유무 확인 메소드
	boolean isExist = file.exists();
	=>파일 또는 디렉토리가 존재하는 지 확인. true나 false리턴

-파일 및 디렉토리 생성 및 삭제 메소드
	-createNewFile()
	-mkdir() -> 새로운 디렉토리를 생성 (경로상에 없는 디렉토리를 넣으면 에러발생)
	-mkdirs() -> 경로상에 없는 모든 디렉토리를 생성 (그래서 s 즉 복수가 붙음)
		=> 경로상에 디렉토리가 확실하지 않을때는 mkdirs()를 사용하는것이 좋음
	-delete() 파일 또는 디렉토리 삭제


- 파일 및 디렉토리의 정보를 리턴하는 메소드
	-canExecute() 실행할 수있는 파일인지 여부
	-canRead() 읽을수 있는지
	-canWrite() 데이터를 수정, 저장할수있는지
	-getName() 파일의 이름을 리턴
	-getParent() 부모 디렉토리를 리턴
	-getParentFile() 부모디렉토리를 File 객체로 생성하고 그 File을 리턴
	-getPath() 전체 경로를 리턴
	-isDirectory() 디렉토리인지 여부
	-isFile() 파일인지 여부
	-isHidden () 숨김 파일인지 여부
	-lastModified()  마지막 수정날짜 및 시간을 리턴
	-lentgh() 파일의 크기 리턴 (사이즈가 아니라 렝스임!)
		=> long타입으로 리턴됨 중요!
	- list() 디렉토리에 포함된 파일 및 서브디렉토리 목록 전부를 
		String 배열로 리턴
	- list(FilenameFilter filter) 디렉토리에 포함된 파일 및 서브디렉토리 목록중에
		FilenameFilter에 맞는 것만 String 배열로 리턴
		-> 필터링을 하는 것임
	- listFiles() 디렉토리에 포함된 파일 및 서브 디렉토리 목록 전부를
		File배열로 리턴
	- listFiles(FilenameFilter filter) 디렉토리에 포함된 파일 및 서브디렉토리 목록중에
		FilenameFilter에 맞는 것만 File배열로 리턴


○ FileInputStream
- 파일로부터 바이트 단위로 읽어 들일 때 사용
	- 그림, 오디오, 비디오, 텍스트 파일등 모든 종류의 파일을 읽을 수 있다.
- 객체 생성방법
	1) FileInputStream fis = new FileInputStream ("경로");

	2) File file = new File (경로);
	   FileInputStream fil = new FileInputStream (file);

- FileInputSteram 객체가 생성될 때 파일과 직접 연결
	예외처리해야한다!

- InputStream 하위 클래스 이므로 사용 방법이 InputStream과 동일하다. 

○FileOutputStream
- 파일에 바이트 단위로 데이터를 저장할 때 사용

- 파일이 이미 존재할 경우, 데이터를 출력하게 되면 파일을 덮어쓰게 됨.
- 기존 파일 내용 끝에 데이터를 추가할 경우, 두번째 매개변수에 true를 넣으면댐
FileOutputStream fis = new FileOutputStream (file, true);

1-5 보조 스트림

○ 보조 스트림
- 다른 스트림과 연결이 되어 여러가지 편리한 기능을 제공해주는 스트림
	입력스트림과 출력스트림에 연결하여 프로그램에 자료를 받거나 출력함
	ex> 문자 변환, 입출력 성능 향성, 기본 데이터 타입 입출력, 객체 입출력 등 기능 제공

- 보조 스트림 생성
	보조스트림 변수 = new 보조스트림 (연결 스트림)

- 보조 스트림 체인
	-> 보조스트림에 보조스트리을 또 붙일 수 있음
	-> 데이터를 문자로변환(보조1) 하고 성능향상(보조2)  -> 프로그램전달
	=> 요렇게 체인으로!

○ 문자 변환 보조 스트림
- 소스 스트림이 바이트 기반 스트림이지만 데이터가 문자일 경우사용할 수 있다.
	- Reader와 Writer는 문자 단위로 입출력하기 때문에 바이트 기반 스트림보다 편리
	- 문자셋의 종류를 지정할 수 있기 때문에 다양한 문자를 입출력

- InputStreamReader
	-> 문자 변환 보조 스트림 InputStream을 가지고 Reader를 만든다.
	바이트를 문자로 읽게끔 해준다.

InputStream is = System.in;
Reader reader = new InputStreamReader(is);

FileInputStream fis = new FileInputStream ("C:/Temp/file.txt");
Reader reader = new InputStreamReader(fis);

※문자 변환 보조스트림이 없이는 바이트로 받으면 또 문자로 변환하는 과정이 필요하다. 

-OutputStreamWriter
	-> 문자를 바이트로 변경하여 보낼경우

프로그램 문자데이터-> OutputStreamWriter -> outputstream -> 바이트

FileOutPutStream fos = new FileOutputStream ("C:/Temp/file.txt");
Writer writer = new OutputStreamWriter(fos);



○성능 향상 보조 스트림
- 입출력 성능에 영향을 미치는 입출력 소스
	- 하드디스크 -> 이걸로 입출력하면 가장 느림
		프로그램이 아무리 빨라도 하드디스크 속도에 맞춤
	- 느린 네트워크 -> 아무리 빨리 데이터를 보내고싶어도
		네트워크가 느리면 느리게감

- 버퍼를 이용한 해결
	- 프로그램이 입출력 소스와 직접 작업하지 않고 버퍼와 작업함으로써 실행 성능을 향상
	프로그램 -> 메모리 버퍼 -> 하드디스크
	※한번에 버퍼 내용 모두를 전송
	즉, 버퍼에 데이터를 고속으로 전송시키고 그 메모리 버퍼에
	데이터를 쌓고, 꽉차게 되면 한번에 데이터를 하드에 전송함 (flush!)

	- 프로그램은 쓰기속도가 향상
	- 버퍼가 차게 되면 데이터를 한번에 하드에 보냄으로써 출력 횟수를 줄여준다. 빨라짐


- 입력 버퍼 제공 : BufferedInputStream, BufferedReader
	프로그램으로 데이터를 읽을 때 고속으로 !

- 출력 버퍼 제공 : BufferedOutputStream, BufferedWriter
	프로그램에서 데이터를 출력할때 고속으로


○ 객체 입출력 보조 스트림
- 객체를 파일 또는 네트워크로 입출력할 수 있는 기능 제공

-ObjectInputStream, ObjectOutputStream을 사용해서
객체를 쉽게 전송이 가능하다. 
	-> 프로그램의 객체를 바이트단위로 변경하여 출력스트림으로 가져오고, 내보낸다.
	이런 과정을 '직렬화' 라고한다.
	객체를 바이트화 시키는것을 직렬화
	바이트를 객체로 만드는것을 역직렬화 라고한다. 



○직렬화가 가능한 클래스 (Serializable)
	->직렬화가 되어있지 않은 클래스는 객체입출력이 불가능하다.
	-> Java는 Serializable 인터페이스를 구현한 클래스만 직렬화 할 수 있도록 제한한다.

	-transient 키워드가 붙은 필드는 직렬화에서 제외됨


-serialVersionUID필드
	-> 식별값임
	-> 직렬화된 객체를 역직렬화할때는 직렬화 했을 때와 같은 클래스를 사용해야함
	-> 클래스의 이름이 같더라도 클래스의 내용이 변경된 경우 역직렬화는 실패한다. 
		=> 클래스가 변경된 경우..!
	-> serialVersionUID는 같은 클래스임을 알려주는 식별자 역할
		=> Serializable인터페이스가 구현되면 컴파일시 자동적으로
		 serialVersionUID 정적 필드가 추가됨
		=> 재컾아링하면 UID 의 값이 달라진다.
	-> 불가피한 수정이 있을 경우 명시적으로 UID를 선언한다.
		-> static final long serialVersionUID = 정수값; << 상수로줘야함


 cmd에서 얻은 UID : private static final long serialVersionUID = -1265691405514514962L;
UID값을 전송하려는 객체에 선언해주면, 그 선언된 객체는 수정이되어도
직렬화, 역직렬화가 오류없이 가능해진다. 


1-6 네트워크 기초
	











