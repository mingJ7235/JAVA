1장. 프로세스와 스레드

프로세스 -> 실행중인 하나의 프로그램을 말한다.
	하나의 프로그램은 다중 프로세스를 만들기도한다.
	※하나의 프로그램이 하나의 프로세스만을 가지지않는다.
	독립적인 여러가지의 프로세스를 가진다.
	몇번을 실행했느냐에 따라서 여러개의 프로세스가 생성됨

멀티태스킹 -> 두가지 이상의 작업을 동시에 처리하는 것
	(음악들으면서 문서작업을 한다던지 등)
	한시점에 여러가지 작업을 동시에 처리

	1) 프로세스를 여러가지 실행하는 방법
	-> 독립적으로 여러가지 프로그램을 실행
	2) 멀티스레드를 사용하는 방법
	-> 한개의 프로세스 내부에서 여러가지 작업을 실행하는것
	-> 카톡 프로세스내에서 채팅, 파일전송 이 함께 멀티로 되는것

1-1절 프로세스와 스레드

메인 스레드
-> 모든 자바프로그램은 메인 스레드가 main()을 실행하면서 시작함
	=> main 스레드는 JVM에의해서 생성됨
※스레드는 코드의 실행 흐름이다. 라고 생각하면 된다. 
-> 메인스레드는 작업스레드들을 만든다.
	=> 즉, 메인은 JVM이 만들고, 다른 작업스레드는 메인스레드가 만든다.
		=> 병렬로 코드를 실행할 수 있다.
-> 프로세스 내부에 있는 모든 스레드가 종료가 되어야 프로세스가 종료된다
	=> 즉, 메인이 먼저 종료되도 작업이 종료되어야
		프로세스가 종료된다.

-> 프로세스의 종료
	ㅁ 싱글 스레드 : 메인 스레드가 종료하면 프로세스도 종료된다.
	ㅁ 멀티 스레드 : 실행중인 스레드가 하나라도 있다면
			프로세스는 종료되지 않는다.
	※ 메인 스레드가 작업스레드보다 먼저 종료되도 작업스레드가
	계속 실행중이라면 프로세스는 종료되지 않는다.


1-2절 작업 스레드 생성과 실행

먼저 몇개의 작업을 실행할지 디자인 해야한다.

※메인스레드를 제외하고 동시에 작업할 작업을 결정해야한다.

작업스레드 생성방법
1) Thread 클래스로 부터 직접 생성
2) Thread 하위 클래스로부터 생성


1) Thread 클래스로부터 직접 생성
	작업 스레드를 만들기위해 Runnable 을 implements 받는다.
	run()을 반드시 재정의해야한다. 
	run()안에 스레드가 실행할 코드를 적는다. 

	how1) 정석적임
	작업을한 클래스를 객체화하고, Runnable 타입으로 받는다.
	Thread 타입으로 객체를 만든 다음에 매개에 작업클래스 객체를 넣는다.

	how2) 익명클래스
	Thread 타입의 객체에 Runnable 인터페이스 객체를
	구현객체를 하면서 익명 클래스를 만든다.
	
	how3)람다식
	Runnable 이라는 인터페이스는 run()메소드만 있으므로
	람다식 표현이 가능함

	만든 후, thread.start() 로 실행함
	run()이 아니라! start()로 실행하는것임
	start()로 실행하면 run() 이 실행된다.


2) Thread 하위 클래스로부터 생성
	-> 직접 만들때는 Thread 생성자의 매개체가 필요했으나
	하위클래스로 만들면, thread 객체를 생성하여 사용가능
	

작업 스레드 생성과 실행
	메인 스레드 이름 : main	
	작업 스레드 이름 : Thread-n (번호가 매겨짐
	※ thread.getName(); 하면 그 스레드 이름이 호출됨

스레드 이름을 사용하는 단계 : 디버깅할때, 스레드이름 확인할때

1-3절 스레드 우선순위

동시성 : 멀티작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행
	-> 한 코어에서 2개이상의 멀티스레드가 실행
	-> 하나의 코어에서는 원칙상 하나의 스레드만 실행함
	그렇기때문에, 하나씩 매우 빠른시간을 통해 번갈아가면서
	스레드들을 실행하는 형태다.
	한번에 하나의 스레드를 실행 !!
	Concurrency

병렬성 : 멀티작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행
	-> 한 코어는 1개의 스레드만을 실행하므로
	각각의 코어에서 하나의 스레드를 여러개의 코어로 사용
	=> 이것이 가장 바람직한 멀티 작업이다.
	서로의 스레드가 실행에 방해를 받지 않고 실행함.
	Parallelism
	
※동시성은 하나의 코어가 하나의 스레드를 실행하는 중에는
	다른 스레드는 대기상태다. 
	옛날 cpu들은 싱글 코어라서 이렇게 동시성으로
	스레드들이 번갈아가면서 실행되었다.
	(번갈아 실행하는 시간타임이 상당히 빠르다.
	그렇기에, 사람눈으로는 식별이안되서
	동시에 작업이 실행되는것처럼 인식된다.)

스레드 스케쥴링
	- 스레드의 개수가 코어의 수보다 많을 경우
	(하나의 코어에 여러가지 스레드가 있을경우)
	
	- 스레드를 어떤순서로 동시성으로 실행할 것인가 결정
	=> 이것이 스레드 스케쥴링
	- 모든 스레드들은 생성하면 실행 대기 상태다.
	- 스케쥴링을 통해 스레드를 선택하여 실행
	- 스케률링에 의해 스레드들은 번갈아가면서
	run()메소드를 조금씩 실행한다. 


- 우선순위 (Prioirity) 방식
	=> 코드로 제어가능
	=> 우선순위가 높은 스레드가 실행상태를 더 많이 
	가지도록 스케쥴링 하는 바식
	=> 순위에 대한 숫자를 주어서 제어함 (우선순위가 높은것이먼저)

- 순환 할당 (Round-Robin) 방식
	=> 코드로 제어 불가
	=> 시간할당량 (Time Slice)를 정해서 
	하나의 스레드를 정해진 시간만큼 실행하는 방식


- 스레드 우선순위
	스레드들이 동시성을 가질 경우 우선적으로 실행할 수 있는 순위
	우선순위 : 1 ~10 (1이 가장낮고 10이 높음) 으로 부여
	default 값 : 기본적으로 5의 우선순위를 할당받음
	
	- 우선순위 변경방법
	thread.setPriority (우선순위); //여기에 숫자를 넣거나
	아래와같이 상수를 넣으면된다.
	thread.setPrioirty (Thread.MAX_PRIORITY); //최우선순위 10
	thread.setPrioirty (Thread.NORM_PRIORITY); //5
	thread.setPrioirty (Thread.MIN_PRIORITY); //가장 낮음 1

	- 우선순위 효과
	● 싱글코어인경우
	- 우선순위가 높은 스레드가 실행기회를 더 많이 가지기 때문에
	우선순위 낮은 스레드보다 계산 작업을 빨리 끝낸다.
	■ 멀티코어인경우
	- 쿼드코어의 경우 4개의 스레드가 병렬성으로 실행되기때문에
	4개이하이 스레드를 실행할 경우에는 우선순위방식은
	크게 영향을 미치지 못한다.
	최소한 5개이상의 스레드가 실행되어야
	우선순위를 지정한 효과를 볼수있다. 


1-4 동기화 메소드와 동기화 블록

공유 객체를 사용할 때의 주의할 점
	멀티 스레드가 하나의 객체를 공유해서 생기는 오류

동기화 메소드 및 동기화 블록 -synchronized 
	단 하나의 스레드만 실행할 수 있는 메소드 또는 블록
	다른 스레드는 메소드나 블록이 실행 끝날때까지 대기해야한다.
	일반메소드는 스레드가 동시에 사용가능하지만
	동기화 메소드, 동기화블록은 단 하나의 스레드만 실행 가능하다.


동기화 메소드
-> 메소드 정의후, 리턴값 앞에 synchronized를 붙이면된다.
	=> 이걸 붙이면 단 하나의 스레드만 실행하도록한다. 
	(이것을 임계영역) 이라고 한다. 

ex) public synchronized void method 9) {
	임계영역; //단 하나의 스레드만
}

동기화 블록

public void method () {
//여러 스레드가 실행 가능 영역
....
	synchronized (공유객체 보통 this가 들어옴.) {
		임계영역; //단 하나의 스레드만 실행
		//하나의 스레드가 실행중이면
		//다른 스레드는 실행 불가함	
	}
//여러 스레드가 실행 가능 영역
...
}

synchronized를 사용하면 객체를 잠근다.
객체 잠금이 되므로 객체 전체 자체가 잠금이 된다.

스레드1이 동기화 메소드 1을 실행하고있다면
스레드 2는 동기화 메소드 1뿐아니라 다른 동기화 메소드, 블록을
모두 실행 못한다. 하지만 일반 메소드는 실행가능하다.


1-5 스레드 상태

스레드를 객체 생성을 하면 실행대기 (Runnable) 이 되는것임.
대기 <-> 실행을 반복하는 것임.

이런과정에서 실행대기에서 실행하지 않고 일시정지 상태로
가는 경우도 있음. 

객체 생성 -> NEW : 스레드 객체 생성, 아직 start() 호출되지 않은상태
실행 대기 -> Runnable : 실행상태로 언제든지 갈 수 있는 상태
		
일시 정지 -> Blocked : 사용코자 하는 객체의 락이 풀릴때까지 기다리는 상태
		다른 스레드가 동기화 메소드나 필드를 실행할때
		걸리는 상태임. 
		본인 차례가 되어 동기화 메소드, 필드를 실행할때
		runnable로 간다.
	     Waiting : 다른 스레드가 통지할 때까지 기다리는 상태
			wait 메소드를 사용시 
			notify라는 메소드를 다른 스레드가 사용해야
			runnable로 간다. 
	     Timed_Waiting : 주어진 시간 동안 기다리는 상태
			sleep 메소드 사용 -> 그시간동안 일시정지
			주어진 시간이 지나면 자동적으로 runnable로감
종료 -> Terminated : 스레드가 실행을 마친 상태
	스레드는 한번 실행하면 종료가되면 소멸됨 재사용이안됨
	재사용을 하기위해서는 다시 객체를 생성해서 사용해야한다.


1-6 스레드 상태 제어

상태제어
	-< 실행중인 스레드의 상태를 변경하는 것을 말함
	-< 상태 변화를 가져오는 메소드들이 있음 !

1) sleep () _ 주어진 시간동안 일시정지
	- 얼마동안 일시 정지 상태로 있을 것인지 밀리세컨드 단위로 지정
	- 일시정지 상태에서 interrupt() 메소드가 호출되면
	interruptedException 이 발생된다. 
	=> sleep도중에 interrupt() 메소드를 호출하게 될 경우 예외 발생하는 것임
	- 반드시 예외처리가 필요함


2) yield () _ 다른 스레드에게 실행 양보
	- 실행중일때 yield() 메소드를 호출하면, 동일 또는 높은 우선순위에있는
	다른 스레드가 실행할 수 있도록 양보하고, 다시 실행 대기상태로 감
	- 즉, 현재 실행하고있는 스레드를 즉시 실행대기상태(runnable)로 되돌림
	

3) join() _ 다른 스레드의 종료를 기다림
	- 헷갈리기 쉬움!!
	- 계산 작업을 하는 스레드가 모든 계산 작업을 마쳤을 때,
	그 계산 값을 받아서 이용하는 경우에 주로 사용한다.
	- 사용하는 스레드가 종료를 기다리는 것이다. 
	- join()을 호출한 스레드가 run()이끝날때까지 기다리는 것임.
	- join의 의미를 잘 이해할 것 !

4) wait(), notify(), notyfyall() _ 스레드간 협업
	-> 얘네는 스레드가 가지고 있는 메소드들이 아니다!!!!
	-> Object가 가지고 있는 메소드다 (즉, 모든 객체가 가지고있는 메소드임)
	-> 동기화 메소드 또는 동기화 블록에서만 호출가능하다!!!!!!
	-> 일반 메소드에서는 호출할 수 가 없다. 
	
	● wait () : 호출한 스레드는 일시 정지가 된다. 
	-> waiting pool에서 관리가 된다. 
	-> 자기 혼자는 절대 실행 대기상태로 못간다
	-> notify() 또는 notifyAll() 을 다른 스레드가 호출해야 실행 대기 상태가된다.
	
	● wait (long timeout), wait(long timeout, int nanos)
	-> wait를 오버라이딩한 메소드
	-> notify()가 호출되지 않아도 매개값에 들어간 시간이 지나면
	스레드가 자동적으로 실행 대기 상태가 된다!!
	-> 원래 wait는 혼자 절대 못감
	-> 하지만, 그 시간이 지나기 전에 다른 메소드가
	notify(), notifyAll()을 다른 스레드가 호출되면 실행대기 상태가 된다.
	-> sleep()은 그 시간이 지나야만 실행대기상태가되는데,
	-> wait()는 그 시간이 다 안지나도 notify, notifyAll이 되면 실행대기로간다.

	언제사용하는가? 
	-> 두개의 스레드가 교대로 번갈아가며 실행해야할 경우에 주로 사용
	-> 보통 공유객체를 번갈아가면서 스레드들이 사용할 때 많이 사용됨
	(synchronized) !!!
	-> 그렇기에 동기화 메소드, 블록에서만 호출가능하다. 
		








