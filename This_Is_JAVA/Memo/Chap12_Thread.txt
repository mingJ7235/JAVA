1장. 프로세스와 스레드

프로세스 -> 실행중인 하나의 프로그램을 말한다.
	하나의 프로그램은 다중 프로세스를 만들기도한다.
	※하나의 프로그램이 하나의 프로세스만을 가지지않는다.
	독립적인 여러가지의 프로세스를 가진다.
	몇번을 실행했느냐에 따라서 여러개의 프로세스가 생성됨

멀티태스킹 -> 두가지 이상의 작업을 동시에 처리하는 것
	(음악들으면서 문서작업을 한다던지 등)
	한시점에 여러가지 작업을 동시에 처리

	1) 프로세스를 여러가지 실행하는 방법
	-> 독립적으로 여러가지 프로그램을 실행
	2) 멀티스레드를 사용하는 방법
	-> 한개의 프로세스 내부에서 여러가지 작업을 실행하는것
	-> 카톡 프로세스내에서 채팅, 파일전송 이 함께 멀티로 되는것

1-1절 프로세스와 스레드

메인 스레드
-> 모든 자바프로그램은 메인 스레드가 main()을 실행하면서 시작함
	=> main 스레드는 JVM에의해서 생성됨
※스레드는 코드의 실행 흐름이다. 라고 생각하면 된다. 
-> 메인스레드는 작업스레드들을 만든다.
	=> 즉, 메인은 JVM이 만들고, 다른 작업스레드는 메인스레드가 만든다.
		=> 병렬로 코드를 실행할 수 있다.
-> 프로세스 내부에 있는 모든 스레드가 종료가 되어야 프로세스가 종료된다
	=> 즉, 메인이 먼저 종료되도 작업이 종료되어야
		프로세스가 종료된다.

-> 프로세스의 종료
	ㅁ 싱글 스레드 : 메인 스레드가 종료하면 프로세스도 종료된다.
	ㅁ 멀티 스레드 : 실행중인 스레드가 하나라도 있다면
			프로세스는 종료되지 않는다.
	※ 메인 스레드가 작업스레드보다 먼저 종료되도 작업스레드가
	계속 실행중이라면 프로세스는 종료되지 않는다.


1-2절 작업 스레드 생성과 실행

먼저 몇개의 작업을 실행할지 디자인 해야한다.

※메인스레드를 제외하고 동시에 작업할 작업을 결정해야한다.

작업스레드 생성방법
1) Thread 클래스로 부터 직접 생성
2) Thread 하위 클래스로부터 생성


1) Thread 클래스로부터 직접 생성
	작업 스레드를 만들기위해 Runnable 을 implements 받는다.
	run()을 반드시 재정의해야한다. 
	run()안에 스레드가 실행할 코드를 적는다. 

	how1) 정석적임
	작업을한 클래스를 객체화하고, Runnable 타입으로 받는다.
	Thread 타입으로 객체를 만든 다음에 매개에 작업클래스 객체를 넣는다.

	how2) 익명클래스
	Thread 타입의 객체에 Runnable 인터페이스 객체를
	구현객체를 하면서 익명 클래스를 만든다.
	
	how3)람다식
	Runnable 이라는 인터페이스는 run()메소드만 있으므로
	람다식 표현이 가능함

	만든 후, thread.start() 로 실행함
	run()이 아니라! start()로 실행하는것임
	start()로 실행하면 run() 이 실행된다.


2) Thread 하위 클래스로부터 생성
	-> 직접 만들때는 Thread 생성자의 매개체가 필요했으나
	하위클래스로 만들면, thread 객체를 생성하여 사용가능
	

작업 스레드 생성과 실행
	메인 스레드 이름 : main	
	작업 스레드 이름 : Thread-n (번호가 매겨짐
	※ thread.getName(); 하면 그 스레드 이름이 호출됨

스레드 이름을 사용하는 단계 : 디버깅할때, 스레드이름 확인할때

1-3절 스레드 우선순위

동시성 : 멀티작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행
	-> 한 코어에서 2개이상의 멀티스레드가 실행
	-> 하나의 코어에서는 원칙상 하나의 스레드만 실행함
	그렇기때문에, 하나씩 매우 빠른시간을 통해 번갈아가면서
	스레드들을 실행하는 형태다.
	한번에 하나의 스레드를 실행 !!
	Concurrency

병렬성 : 멀티작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행
	-> 한 코어는 1개의 스레드만을 실행하므로
	각각의 코어에서 하나의 스레드를 여러개의 코어로 사용
	=> 이것이 가장 바람직한 멀티 작업이다.
	서로의 스레드가 실행에 방해를 받지 않고 실행함.
	Parallelism
	
※동시성은 하나의 코어가 하나의 스레드를 실행하는 중에는
	다른 스레드는 대기상태다. 
	옛날 cpu들은 싱글 코어라서 이렇게 동시성으로
	스레드들이 번갈아가면서 실행되었다.
	(번갈아 실행하는 시간타임이 상당히 빠르다.
	그렇기에, 사람눈으로는 식별이안되서
	동시에 작업이 실행되는것처럼 인식된다.)

스레드 스케쥴링
	- 스레드의 개수가 코어의 수보다 많을 경우
	(하나의 코어에 여러가지 스레드가 있을경우)
	
	- 스레드를 어떤순서로 동시성으로 실행할 것인가 결정
	=> 이것이 스레드 스케쥴링
	- 모든 스레드들은 생성하면 실행 대기 상태다.
	- 스케쥴링을 통해 스레드를 선택하여 실행
	- 스케률링에 의해 스레드들은 번갈아가면서
	run()메소드를 조금씩 실행한다. 


- 우선순위 (Prioirity) 방식
	=> 코드로 제어가능
	=> 우선순위가 높은 스레드가 실행상태를 더 많이 
	가지도록 스케쥴링 하는 바식
	=> 순위에 대한 숫자를 주어서 제어함 (우선순위가 높은것이먼저)

- 순환 할당 (Round-Robin) 방식
	=> 코드로 제어 불가
	=> 시간할당량 (Time Slice)를 정해서 
	하나의 스레드를 정해진 시간만큼 실행하는 방식


- 스레드 우선순위
	스레드들이 동시성을 가질 경우 우선적으로 실행할 수 있는 순위
	우선순위 : 1 ~10 (1이 가장낮고 10이 높음) 으로 부여
	default 값 : 기본적으로 5의 우선순위를 할당받음
	
	- 우선순위 변경방법
	thread.setPriority (우선순위); //여기에 숫자를 넣거나
	아래와같이 상수를 넣으면된다.
	thread.setPrioirty (Thread.MAX_PRIORITY); //최우선순위 10
	thread.setPrioirty (Thread.NORM_PRIORITY); //5
	thread.setPrioirty (Thread.MIN_PRIORITY); //가장 낮음 1

	- 우선순위 효과
	● 싱글코어인경우
	- 우선순위가 높은 스레드가 실행기회를 더 많이 가지기 때문에
	우선순위 낮은 스레드보다 계산 작업을 빨리 끝낸다.
	■ 멀티코어인경우
	- 쿼드코어의 경우 4개의 스레드가 병렬성으로 실행되기때문에
	4개이하이 스레드를 실행할 경우에는 우선순위방식은
	크게 영향을 미치지 못한다.
	최소한 5개이상의 스레드가 실행되어야
	우선순위를 지정한 효과를 볼수있다. 


1-4 동기화 메소드와 동기화 블록

공유 객체를 사용할 때의 주의할 점
	멀티 스레드가 하나의 객체를 공유해서 생기는 오류

동기화 메소드 및 동기화 블록 -synchronized 
	단 하나의 스레드만 실행할 수 있는 메소드 또는 블록
	다른 스레드는 메소드나 블록이 실행 끝날때까지 대기해야한다.
	일반메소드는 스레드가 동시에 사용가능하지만
	동기화 메소드, 동기화블록은 단 하나의 스레드만 실행 가능하다.


동기화 메소드
-> 메소드 정의후, 리턴값 앞에 synchronized를 붙이면된다.
	=> 이걸 붙이면 단 하나의 스레드만 실행하도록한다. 
	(이것을 임계영역) 이라고 한다. 

ex) public synchronized void method 9) {
	임계영역; //단 하나의 스레드만
}

동기화 블록

public void method () {
//여러 스레드가 실행 가능 영역
....
	synchronized (공유객체 보통 this가 들어옴.) {
		임계영역; //단 하나의 스레드만 실행
		//하나의 스레드가 실행중이면
		//다른 스레드는 실행 불가함	
	}
//여러 스레드가 실행 가능 영역
...
}

synchronized를 사용하면 객체를 잠근다.
객체 잠금이 되므로 객체 전체 자체가 잠금이 된다.

스레드1이 동기화 메소드 1을 실행하고있다면
스레드 2는 동기화 메소드 1뿐아니라 다른 동기화 메소드, 블록을
모두 실행 못한다. 하지만 일반 메소드는 실행가능하다.


1-5 스레드 상태

스레드를 객체 생성을 하면 실행대기 (Runnable) 이 되는것임.
대기 <-> 실행을 반복하는 것임.

이런과정에서 실행대기에서 실행하지 않고 일시정지 상태로
가는 경우도 있음. 

객체 생성 -> NEW : 스레드 객체 생성, 아직 start() 호출되지 않은상태
실행 대기 -> Runnable : 실행상태로 언제든지 갈 수 있는 상태
		
일시 정지 -> Blocked : 사용코자 하는 객체의 락이 풀릴때까지 기다리는 상태
		다른 스레드가 동기화 메소드나 필드를 실행할때
		걸리는 상태임. 
		본인 차례가 되어 동기화 메소드, 필드를 실행할때
		runnable로 간다.
	     Waiting : 다른 스레드가 통지할 때까지 기다리는 상태
			wait 메소드를 사용시 
			notify라는 메소드를 다른 스레드가 사용해야
			runnable로 간다. 
	     Timed_Waiting : 주어진 시간 동안 기다리는 상태
			sleep 메소드 사용 -> 그시간동안 일시정지
			주어진 시간이 지나면 자동적으로 runnable로감
종료 -> Terminated : 스레드가 실행을 마친 상태
	스레드는 한번 실행하면 종료가되면 소멸됨 재사용이안됨
	재사용을 하기위해서는 다시 객체를 생성해서 사용해야한다.


1-6 스레드 상태 제어

상태제어
	-< 실행중인 스레드의 상태를 변경하는 것을 말함
	-< 상태 변화를 가져오는 메소드들이 있음 !

1) sleep () _ 주어진 시간동안 일시정지
	- 얼마동안 일시 정지 상태로 있을 것인지 밀리세컨드 단위로 지정
	- 일시정지 상태에서 interrupt() 메소드가 호출되면
	interruptedException 이 발생된다. 
	=> sleep도중에 interrupt() 메소드를 호출하게 될 경우 예외 발생하는 것임
	- 반드시 예외처리가 필요함


2) yield () _ 다른 스레드에게 실행 양보
	- 실행중일때 yield() 메소드를 호출하면, 동일 또는 높은 우선순위에있는
	다른 스레드가 실행할 수 있도록 양보하고, 다시 실행 대기상태로 감
	- 즉, 현재 실행하고있는 스레드를 즉시 실행대기상태(runnable)로 되돌림
	

3) join() _ 다른 스레드의 종료를 기다림
	- 헷갈리기 쉬움!!
	- 계산 작업을 하는 스레드가 모든 계산 작업을 마쳤을 때,
	그 계산 값을 받아서 이용하는 경우에 주로 사용한다.
	- 사용하는 스레드가 종료를 기다리는 것이다. 
	- join()을 호출한 스레드가 run()이끝날때까지 기다리는 것임.
	- join의 의미를 잘 이해할 것 !

4) wait(), notify(), notyfyall() _ 스레드간 협업
	-> 얘네는 스레드가 가지고 있는 메소드들이 아니다!!!!
	-> Object가 가지고 있는 메소드다 (즉, 모든 객체가 가지고있는 메소드임)
	-> 동기화 메소드 또는 동기화 블록에서만 호출가능하다!!!!!!
	-> 일반 메소드에서는 호출할 수 가 없다. 
	
	● wait () : 호출한 스레드는 일시 정지가 된다. 
	-> waiting pool에서 관리가 된다. 
	-> 자기 혼자는 절대 실행 대기상태로 못간다
	-> notify() 또는 notifyAll() 을 다른 스레드가 호출해야 실행 대기 상태가된다.
	
	● wait (long timeout), wait(long timeout, int nanos)
	-> wait를 오버라이딩한 메소드
	-> notify()가 호출되지 않아도 매개값에 들어간 시간이 지나면
	스레드가 자동적으로 실행 대기 상태가 된다!!
	-> 원래 wait는 혼자 절대 못감
	-> 하지만, 그 시간이 지나기 전에 다른 메소드가
	notify(), notifyAll()을 다른 스레드가 호출되면 실행대기 상태가 된다.
	-> sleep()은 그 시간이 지나야만 실행대기상태가되는데,
	-> wait()는 그 시간이 다 안지나도 notify, notifyAll이 되면 실행대기로간다.

	언제사용하는가? 
	-> 두개의 스레드가 교대로 번갈아가며 실행해야할 경우에 주로 사용
	-> 보통 공유객체를 번갈아가면서 스레드들이 사용할 때 많이 사용됨
	(synchronized) !!!
	-> 그렇기에 동기화 메소드, 블록에서만 호출가능하다. 
		
5) stop플래그, interrupt () _ 스레드의 안전한 종료
	- 경우에 따라 실행중인 스레드를 즉시 종료할 필요가 있다.
	ex) 뮤직프로그램에서 음악듣다 음악 정지하는 경우
	
	- stop() 메소드 -> deprecated됨
	=> 스레드를 갑자기 종료하게 되면 사용중이던 자원들이
	불안전한 상태로 남겨져서 사용하지 않는다. !!! 

	- stop 플래그 이용 
	=> stop 플래그로 run()메소드의 정상 종료를 유도한다.
	※쓰레드는 run()이 종료되면 쓰레드가 종료된다.
	=> while 반복안에 stop 불린을 만들어서 사용!
	

	-interrupt() 메소드
	=> stop플래그를 사용하면 일시 정지 상태일 경우는 종료시키지 못함
	=> interrup()메소드를 사용하면 일시정지상태인 경우도 종료시킬수있음
	=> interrupt() 메소드를 호출하면 InterruptedExcetion을 발생시키기때문임
	=> runnable 상태나, 실행중인 상태에서는 interruptedExcetion이 발생하지 않는다.
	=> Thread는 일시정지 상태에 있어야지만 interruptedException이 발생한다.
	=> 일시정지 상태가 아닌 상태에서 interrupt()가 호출되면,
	그 다음에 일시정지가 발생이될때 된다.
	
	일시정지하는 코드가 없는곳에서 interrupt()는 일반적으로 못쓴다.
	※ 일시정지 상태로 만들지 않고 while문을 빠져나오는 방법
	=> Thread.interrupted() 는 boolean이 리턴타입.
	-> interrupt() 메소드가 호출되면 true를 리턴함
	-> Thread.interrupted()를 if 문에 넣어서 조건으로 빠져나올수있음

1-7 데몬스레드 (daemon)
주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드
주 스레드가 종료되면 데몬스레드는 강제적으로 자동종료
	ex> 워드프로세서의 자동저장기능, 
	미디어 플레이어의 동영상 및 음악 재생 기능 등
	가비지 컬렉터 (JVM이 실행되고있을때만 의미있는 것임)

데몬스레드 설정
	- 주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출함
	- 반드시 start() 메소드 호출전에 ! setDaemon(trur)를 호출해야한다.!!
		=> IllegalThreadStateException이 발생한다.

데몬 스레드 확인 방법
	- isDaemon() 메소드의 리턴값을 조사 
	(ture면 데몬, false면 주 스레드임)

1-8 스레드 그룹
스레드그룹
	-관련된 스레드를 묶어서 관리할 목적으로 이용
	- 스레드 그룹은 계층적으로 하위 스레드 그룹을 가질 수 있다.
	=> 스레드 그룹 안에 하위 스레드 그룹으로 묶어서
	계층적으로 스레드 그룹을 관리가능
	- 자동 생성되는 스레드 그룹
	-> system 그룹 : JVM 운영에 필요한 스레드들을 포함
	-> system/main 그룹 : 메인 스레드를 포함 (main 그룹은 system그룹 하위)
	-스레드는 반드시 하나의 스레드 그룹에 포함!!
	-> 기본적으로 자신을 생성한 스레드와 같은 스레드 그룹에 속하게 된다.
	-> 명시적으로 포함시키지 않으면 기본적으로 system/main 그룹에 속한다
					=> main 스레드가 속한 곳


스레드 그룹 생성
	ThreadGroup tg = new ThreadGroup (String name);
	=> 객체화하고 생성자에 매개값으로 그룹의 이름을 주는 것임
	=> 부모그룹을 지정하지 않은 경우
	
	ThreadGroup tg = new (ThreadGroup Parent, String name);
	=> 부모 지정

	부모 그룹을 지정하지 않으면 현재 스레드가 속한 그룹의 하위 그룹으로
	생성. 

	스레드를 그룹에 명시적으로 포함시키는 방법

왜스레드그룹을 사용하는가? 
=> 스레드 그룹의 일괄 interrupt()
스레드 그룹의 interrupt()를 호출하면 소속된 모든 스레드의 interrupt()가 호출된다.
스레드 그룹에서 1번 호출하면 모든 소속 thread에서 interrupt()가 호출되어
안전하게 종료가 된다. 


1-9 스레드 풀 (ExecutorService)
○스레드 폭증
	- 병렬 작업 처리가 많아지면 스레드 갯수가 증가한다
	- 스레드 생성과 스케쥴링으로 인해 cpu가 바빠지고, 메모리사용량 늘어남
	- so, 어플리케이션의 성능이 급격히 저하됨.
	- 동시에 수백개의 스레드가 병렬처리가 된다면...
	- 이런 경우는? 서버 폭발 같은 경우

○스레드 풀 (thread Pool) -> 스레드를 미리 생성해서 폭증을 막기위해 사용
	- 작업처리에 사용되는 스레드를 제한된 개수만큼 미리생성
		=> 제한된 개수만큼!!! 이 중요함
		=> 무한히 늘어나지 않도록 스레드를 제한시킴
	- 작업 큐 (Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리함
		=> 여러 작업들이 요청이 들어오는데,	
		이 작업들을 Queue에 차곡차곡 저장을 했다가,
		저장된 작업들을 제한된 스레드가 하나씩 끄잡아와서 처리함
		작업을 끝낸 스레드는 그 다음 작업을 꺼내와서 작업함
		계속해서 Queue에 있는 작업들을 계속해서 작업하기에
		제한된 갯수로도 작업이 가능하다
	- 작업 처리가 끝난 스레드는 작업 결과를 애플리케이션으로 전달
		작업을 큐에서 꺼내서 스레드가 작업하고 다시 결과를 전달
	- 스레드는 작업큐에서 다시 새로운 작업을 가져와 처리함
※ 갑자기 많은 작업이 들어와도 작업큐의 작업만 늘어날 뿐이므로
스레드 폭증이 일어나지 않는다. (제한된 수!)
=> 서버에서 사용함. 매우중요

○ExucutorService 인터페이스와 Executors 클래스 
	- 스레드풀을 생성하고 사용할수 있도록 java.util.concurrent 패키지에서 제공됨
	- Executors의 정적 메소드를 이용해서 ExecutorService구현 객체 생성
	- 스레드 풀 = ExecutorService 객체 !!


○스레드풀 생성
	코어스레드 수 : 놀고있는 스레드를 제거할 때 최소한 유지해야할 스레드수
	최대 스레드 수 : 최대로 생성할수 있는 스레드 수 

newCachedThreadPool() : 
	- int 값이 가질 수 있는 최대 값만큼 스레드가 추가되나,
	os 상황(메모리상황)에 따라 달라진다. 
	- 1개 이상이 스레드가 추가 되었을 경우
	- 60초 동안 추가된 스레드가 아무작업하지 않으면 추가된 스레드를 
	종료하고 풀에서 제거한다. -
	-코어스레드수가 0이므로 아무작업 없으면 모두 제거임
	ExecutorService executorService = Executors.newCachedThreadPool();

newFixedThreadPool (int n Threads) :
	- 매개값으로 코어스레드와 최대 스레드수를 주게된다.
	- 코어 스레드, 최대스레드 개수가 매개값으로 준 스레드이다.
	- 한번 작업한 스레드는 놀고있어도 스레드개수가 줄지 않는다.
	- 코어스레드 수와 최대스레드 수가 같기 때문이다	
	ExecutorService executorService = Executors.newFixedThreadPool(
	Runtime.getRuntime().availableProcessors()
	// 여기서는 cpu가 가지고 있는 현재 코어 갯수를 준것임
	// 쿼드 코어라면 4가 될것임
	// 꼭 이렇게 지정할 필요는 없으나, 잘 생각해서 지정해야한다.
	);

ThreadPoolExecutor를 이용한 직접 생성
	- 스레드의 수를 자동으로 관리하고 싶을 경우 직접 생성해서 사용
	ex> 코어스레드개수가 3, 최대스레드개수가 100인 스레드풀 생성하고싶을때
	3개를 제외한 나머지 추가된 스레드가 120초 동안 놀고있을경우 제거
	(매개값이 5개다)
	ExecutorService threadPool = new ThreadPoolExecutor (
	3, //코어스레드갯수
	100,//최대스레드갯수
	120L,//놀고있는시간
	TimeUnit.SECONDS,//놀고있는 시간 단위
	new SynchronousQueue<Runnalble>() //작업 큐
	);

○스레드풀 종료
	- 스레드풀의 스레드는 기본적으로 데몬 스레드가 아니다.
	=> main 스레드가 종료되더라도 스레드풀의 스레드는 작업을
	처리하기 위해 계속 실행되므로 애플리케이션은 종료되지 않는다.
	=> 즉, 스레드풀을 종료해서 모든 스레드를 종료시켜야한다. 

종료 메소드
	- shutdown () : 현재 처리중인 작업뿐아니라, 작업큐에 대기하고있는
	모든 작업을 처리한 뒤에!! 스레드풀을 종료시킨다. (권장됨)

	-shutdownNow() :  현재 작업 처리중인 스레드를 interrupt 해서
	작업 중지를 시도하고 스레드 풀을 종료시킨다.
	리턴값은 작업큐에 있는 미처리된 작업(Runnable)의 목록이다.!!
	=> 즉, 리턴타입 List<Runnable>
	가급적이면 shutdownNow는 호출하지 않는것이 좋다. 
	강제종료임	

	- awaitTermination (long timeout, TimeUnit unit)
	shutdown() 메소드 호출 이후, 모든 작업처리를 timeout 시간내에
	완료하면 true를 리턴하고, 
	완료하지 못하면 작업 처리중인 스레드를 interrupt하고 false를 리턴한다
	두번째 매개변수 unit은 timeout의 단위다 (초인지 분인지 시인지)
	=> 즉, 리턴타입은 boolean 이다. 

○작업 생성
	-> 하나의 작업은 Runnable 또는 Callable 객체로 표현한다. 

	-Runnable과 Callable의 차이점
	=> 작업 처리 완료 후 리턴값이 있느냐 없느냐 차이!!
	Callable은 리턴값이 있다. 


	- 스레드풀에서 작업처리
	=> 작업 큐에서 Runnable또는 Callable객체를 가져와서
	스레드로 하여금 run() 또는 call()메소드를 실행토록 하게 하는것.!!

○ 작업 처리 요청
	ExecutorService의 작업큐에 Runnable또는 Callable객체를 넣는 것
	- execute (Runnable command) 
	Runnable 객체를 작업큐에 저장한다.
	작업처리 결과를 받지 못한다. (리턴값이 없으므로)
	=> 결과값이 필요없을 경우	

	- submit (Runnable task)
	Runnable 또는 Callable을 작업큐에 저장
	리턴된 Future를 통해 작업 처리 결과 를 얻을 수 있다. 
	(Runnable은 리턴이 없으므로, submit을 오버라이딩한 메소드를 사용하여
	두번째 매개값에 result를 받는다)
	=> 결과값이 필요할경우

	- 작업 처리 도중 예외가 발생할 경우
	execute () : 스레드자체가 종료되고, 해당 스레드는 제거된다.
	즉, 스레드풀은 다른 작업처리를 위해 새로운 스레드를 생성한다. 

	submit() : 스레드가 종료되지 않고 다음 작업을 위해 재사용된다. 
	해당 예외가 발생한 작업은 버리고 
	기존에 예외난 스레드를 바로 다음 작업을 위해 재사용함
	이것이 execute()보다는 submit()을 일반적으로 사용하는 경우다.
	submit()은 리턴값이 없어도 Runable task 매개변수가 1개인
	메소드를 사용하면 된다. 

	=> 일반적으로 execute보다 submit()을 사용한다!


○블로킹 방식의 작업 완료 통보받기
	블로킹 방식 : 뭔가 작업을 요청하고나서 그 요청의 결과가 올때까지 기다리는 방식
	Future는 지연객체다

	-Future
	=> 작업 결과가 아니라 지연 완료 (pending completion)객체
	=> 작업이 완료될때까지 기다렸다가 최종결과를 얻기 위해 get()메소드 사용
	=> 작업 결과가 아니다!! 
	
	-Future의 메소드 (V를 리턴한다. 즉, 작업결과를 리턴함)
	get() : 작업이 완료될 때 가지 블로킹 되었다가 처리 결과 V를 리턴함.
	get (long timeout, TimeUnit unit) : timeout 시간동안 작업이 완료되면
	결과 V를 리턴하지만, 작업이 완료되지 않으면
	TimeoutException을 발생시킨다. => 최대한 기다릴 수 있는 시간을
	매개변수에 넣어준다. (get ()을 오버로딩한 것)

	=> submit 메소드를 사용시 작업 결과!! (execute는 결과값 없음 ) 
	ex> 
	submit(Runnable task) => future.get() -> null 리턴 (
	submit(Runnable task, Integer result) => future.get() -> int 타입 결과값 리턴
	submit(Callable <String> task) => future.get() -> String 타입 결과값 리턴


	○Future 의 get()은 UI 스레드에서 호출하면 안된다.
	-> UI는 멈춰있는 상태가되고 이벤트 처리를 할 수 없다. 
	작업을 완료하기전까지 UI를 변경할 수도 없고 이벤트도 처리할 수 없게 된다.
	
	○Future의 다른 매소드 (3개모두 boolean 타입 리턴)
	- cancel (boolean mayInterruptIfRunning) : 작업 처리가 진행중일 경우 취소 시킴
	- isCancelled() : 작업이 취소되었는지 여부
	- isDone () : 작업 처리가 완료되었는지 여부 


	○리턴값이 있는 작업 완료 통보
	Callable 사용 ! -> <> 제네릭 타입으로 리턴값을 지정해주면 된다. 


○작업 처리 결과를 외부 객체에 저장

