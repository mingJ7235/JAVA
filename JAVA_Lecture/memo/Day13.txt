<싱글톤>

public class 클래스{
   //정적 필드
   private static 클래스 singleton = new 클래스();

   //생성자
   private 클래스(){ } 

  //정적 메소드
  static 클래스 getInstance() {
    return singleton;
  }
}

이 형식 중요함.=> 싱글톤패턴으로 선언하기 중요.

접근할 때 -> 클래스명 변수1 = 클래스.getInstance();

싱글톤 패턴은 힙메모리의 공간에 하나의 자료를 가르킴
API에 많이 나옴. 


<상속>
클래스간의 관계>

1) 포함관계 (import해서 사용하는 것) / has~a 관계
=> ~은 ~을 가지고 있다. / 부속품 느낌
어떤 클래스의 부분적인 메소드를 가지고 오는 것.
ex> scanner 클래스의 입출력 메소드를 가져오고싶다. -> import사용
Scanner 클래스는 수많은 메소드가 있다. 여기서 몇개만 가지고 온다.

2) 상속관계 (extends사용) / is~a관계
=> 포함 관계. '자식 Class 는 부모 Class다.'
공통점을 가지고 있어야 한다. 

Super>
부모 생성자 호출. 

※자식 객체를 생성하면, 부모 객체가 먼저 생성되고, 자식 객체가 그다음에 생성됨

Super를 사용해서 부모 생성자를 호출할 때,
한 번만 사용 가능하다. (this와 같음)

------------------------
이곳은 부모의 정적 블록입니다.
이곳은 자식의 정적 블록입니다.
이곳은 부모의 인스턴스 블록입니다.
부모 기본 생성자
이곳은 자식의 인스턴스 블록입니다.
자식의 생성자
-------------------------
자식의 생성자를 호출할 경우
-> 부모 정적블록 -> 자식 정적블록 -> 부모 인스턴스블록 -> 부모 기본생성자
	-> 자식 인스턴스 블록 -> 자식 생성자 
순서 !!

자식을 생성하면 부모가 먼저 올라간다. 이것을 기억하자. 


Object >

Object는 최상위에 있는 조상클래스다.
Object는 자동상속이 된다. 

※native -> java로 만든 코드를 다른 언어로 convert할 때
	 사용하는 예약어다. 

Override >
overide : ~위에 덮어쓰다.
부모의 메소드를 자식클래스에서 수정하여 사용하는 것.
1) 메소드 재정의
: 부모와 동일한 메소드를 재정의한다. 
2) 규칙
	-부모의 메소드와 동일한 리턴 타입, 메소드 이름, 매개변수 리스트
	-> 3가지가 같아야한다. 
	-접근제어자를 부모클래스의 메소드보다 좁게 변경 불가
	-> public 인데 private으로 변경 불가.
	- 예외는 부모보다 더 많이 선언할 수 없다.
	- 인스턴스 메소드를 static으로, static을 인스턴스로 변경불가


Spring에서는 어노테이션을 많이 사용한다. 
다양한 어노테이션을 배우게 될것. 


final >
클래스에 final => 상속 할 수 없다.
메소드에 final => 오버라이딩 할 수 없다.
필드에 final => 초기값 설정 후 더 이상 값을 변경할 수 없다. 

